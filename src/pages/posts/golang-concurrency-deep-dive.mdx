---
layout: ../../layouts/PostLayout.astro
title: Go å¹¶å‘ç¼–ç¨‹æ·±åº¦è§£æ â€”â€” goroutine å’Œ channel çš„å®æˆ˜æŠ€å·§
date: 2024-12-28
category: åç«¯å¼€å‘
description: æ·±å…¥ç†è§£ Go çš„å¹¶å‘æ¨¡å‹ï¼ŒæŒæ¡ goroutineã€channelã€select ç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œå­¦ä¼šå¤„ç†å¹¶å‘ç¼–ç¨‹ä¸­çš„å¸¸è§é—®é¢˜å’Œæœ€ä½³å®è·µ
tags:
  - Go
  - Golang
  - å¹¶å‘ç¼–ç¨‹
  - goroutine
  - channel
  - åç«¯å¼€å‘
author: fkxgood
---

# Go å¹¶å‘ç¼–ç¨‹æ·±åº¦è§£æ â€”â€” goroutine å’Œ channel çš„å®æˆ˜æŠ€å·§

> å¹¶å‘ç¼–ç¨‹æ˜¯ Go è¯­è¨€æœ€å¸å¼•äººçš„ç‰¹æ€§ä¹‹ä¸€ã€‚goroutine å’Œ channel çš„è®¾è®¡è®©å¹¶å‘ç¼–ç¨‹å˜å¾—ç®€å•è€Œä¼˜é›…ï¼Œä½†çœŸæ­£ç”¨å¥½å®ƒä»¬éœ€è¦æ·±å…¥ç†è§£å…¶å·¥ä½œåŸç†å’Œæœ€ä½³å®è·µã€‚

## ğŸ¤” ä¸ºä»€ä¹ˆ Go çš„å¹¶å‘è¿™ä¹ˆç‰¹åˆ«ï¼Ÿ

åœ¨å­¦ Go ä¹‹å‰ï¼Œæˆ‘å¯¹å¹¶å‘çš„ç†è§£è¿˜åœç•™åœ¨ä¼ ç»Ÿçš„å¤šçº¿ç¨‹æ¨¡å‹ä¸Šã€‚Go çš„å¹¶å‘æ¨¡å‹ç¡®å®è®©äººçœ¼å‰ä¸€äº®ï¼š

| ç‰¹æ€§ | ä¼ ç»Ÿçº¿ç¨‹ | goroutine | ä¼˜åŠ¿ |
|------|----------|-----------|------|
| **å†…å­˜å ç”¨** | 1-2MB æ ˆç©ºé—´ | 2KB åˆå§‹æ ˆ | å¯ä»¥è½»æ¾åˆ›å»ºç™¾ä¸‡çº§ goroutine |
| **åˆ›å»ºæˆæœ¬** | ç³»ç»Ÿè°ƒç”¨ï¼Œå¼€é”€å¤§ | ç”¨æˆ·æ€è°ƒåº¦ï¼Œå¼€é”€å° | åˆ›å»ºå’Œé”€æ¯éƒ½å¾ˆè½»é‡ |
| **è°ƒåº¦æ–¹å¼** | æ“ä½œç³»ç»Ÿè°ƒåº¦ | Go runtime è°ƒåº¦ | æ›´æ™ºèƒ½çš„è°ƒåº¦ç­–ç•¥ |
| **é€šä¿¡æ–¹å¼** | å…±äº«å†…å­˜ + é” | channel é€šä¿¡ | é¿å…ç«æ€æ¡ä»¶ |

### Go å¹¶å‘çš„æ ¸å¿ƒå“²å­¦

**"Don't communicate by sharing memory; share memory by communicating"**

```go
// é”™è¯¯çš„åšæ³• - å…±äº«å†…å­˜
var counter int
var mu sync.Mutex

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}

// æ­£ç¡®çš„åšæ³• - é€šè¿‡é€šä¿¡å…±äº«å†…å­˜
func increment(ch chan int) {
    ch <- 1
}

func main() {
    ch := make(chan int)
    go increment(ch)
    go increment(ch)
    
    // ä» channel æ¥æ”¶ç»“æœ
    result1 := <-ch
    result2 := <-ch
}
```

## ğŸš€ goroutine æ·±å…¥ç†è§£

### goroutine çš„ç”Ÿå‘½å‘¨æœŸ

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func worker(id int, done chan bool) {
    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d done\n", id)
    done <- true
}

func main() {
    // æŸ¥çœ‹å½“å‰ goroutine æ•°é‡
    fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())
    
    done := make(chan bool, 3)
    
    // å¯åŠ¨ 3 ä¸ª goroutine
    for i := 1; i <= 3; i++ {
        go worker(i, done)
    }
    
    fmt.Printf("Goroutines after starting: %d\n", runtime.NumGoroutine())
    
    // ç­‰å¾…æ‰€æœ‰ goroutine å®Œæˆ
    for i := 0; i < 3; i++ {
        <-done
    }
    
    fmt.Printf("Goroutines after completion: %d\n", runtime.NumGoroutine())
}
```

### goroutine çš„è°ƒåº¦æœºåˆ¶

Go ä½¿ç”¨ GMP æ¨¡å‹è¿›è¡Œè°ƒåº¦ï¼š

```go
// G: goroutine
// M: machine (ç³»ç»Ÿçº¿ç¨‹)
// P: processor (å¤„ç†å™¨)

func demonstrateScheduling() {
    // è®¾ç½®æœ€å¤§ CPU æ ¸å¿ƒæ•°
    runtime.GOMAXPROCS(4)
    
    // å¯åŠ¨å¤§é‡ goroutine è§‚å¯Ÿè°ƒåº¦
    for i := 0; i < 1000; i++ {
        go func(id int) {
            // æ¨¡æ‹Ÿ CPU å¯†é›†å‹ä»»åŠ¡
            for j := 0; j < 1000000; j++ {
                _ = j * j
            }
        }(i)
    }
    
    // ç­‰å¾…ä¸€æ®µæ—¶é—´è§‚å¯Ÿè°ƒåº¦
    time.Sleep(time.Second)
    fmt.Printf("Active goroutines: %d\n", runtime.NumGoroutine())
}
```

## ğŸ”„ channel çš„æ·±åº¦ä½¿ç”¨

### channel çš„ç±»å‹å’Œç‰¹æ€§

```go
// 1. æ— ç¼“å†² channel - åŒæ­¥é€šä¿¡
func unbufferedChannel() {
    ch := make(chan int) // æ— ç¼“å†²
    
    go func() {
        fmt.Println("Sending...")
        ch <- 42 // é˜»å¡ç›´åˆ°æœ‰äººæ¥æ”¶
        fmt.Println("Sent!")
    }()
    
    time.Sleep(time.Second)
    fmt.Println("Receiving...")
    value := <-ch // é˜»å¡ç›´åˆ°æœ‰äººå‘é€
    fmt.Printf("Received: %d\n", value)
}

// 2. æœ‰ç¼“å†² channel - å¼‚æ­¥é€šä¿¡
func bufferedChannel() {
    ch := make(chan int, 3) // ç¼“å†²å¤§å°ä¸º 3
    
    // å¯ä»¥å‘é€ 3 ä¸ªå€¼è€Œä¸é˜»å¡
    ch <- 1
    ch <- 2
    ch <- 3
    
    // ç¬¬ 4 ä¸ªä¼šé˜»å¡
    go func() {
        ch <- 4 // è¿™é‡Œä¼šé˜»å¡
        fmt.Println("4 sent")
    }()
    
    // æ¥æ”¶ä¸€ä¸ªå€¼ï¼Œè®©ç¬¬ 4 ä¸ªå¯ä»¥å‘é€
    fmt.Printf("Received: %d\n", <-ch)
    time.Sleep(time.Millisecond * 100)
}
```

### channel çš„é«˜çº§æ¨¡å¼

**1. å·¥ä½œæ± æ¨¡å¼**
```go
func workerPool() {
    const numWorkers = 3
    const numJobs = 10
    
    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)
    
    // å¯åŠ¨å·¥ä½œåç¨‹
    for i := 0; i < numWorkers; i++ {
        go worker(i, jobs, results)
    }
    
    // å‘é€ä»»åŠ¡
    for i := 0; i < numJobs; i++ {
        jobs <- i
    }
    close(jobs)
    
    // æ”¶é›†ç»“æœ
    for i := 0; i < numJobs; i++ {
        fmt.Printf("Result: %d\n", <-results)
    }
}

func worker(id int, jobs <-chan int, results chan<- int) {
    for job := range jobs {
        fmt.Printf("Worker %d processing job %d\n", id, job)
        time.Sleep(time.Millisecond * 100) // æ¨¡æ‹Ÿå·¥ä½œ
        results <- job * 2
    }
}
```

**2. æ‰‡å…¥æ‰‡å‡ºæ¨¡å¼**
```go
// æ‰‡å‡ºï¼šä¸€ä¸ª channel åˆ†å‘ç»™å¤šä¸ª goroutine
func fanOut(input <-chan int, outputs []chan<- int) {
    defer func() {
        for _, ch := range outputs {
            close(ch)
        }
    }()
    
    for value := range input {
        // è½®è¯¢åˆ†å‘
        for _, ch := range outputs {
            ch <- value
        }
    }
}

// æ‰‡å…¥ï¼šå¤šä¸ª channel åˆå¹¶æˆä¸€ä¸ª
func fanIn(inputs ...<-chan int) <-chan int {
    output := make(chan int)
    
    var wg sync.WaitGroup
    wg.Add(len(inputs))
    
    for _, input := range inputs {
        go func(ch <-chan int) {
            defer wg.Done()
            for value := range ch {
                output <- value
            }
        }(input)
    }
    
    go func() {
        wg.Wait()
        close(output)
    }()
    
    return output
}
```

**3. è¶…æ—¶å’Œå–æ¶ˆæ¨¡å¼**
```go
func timeoutExample() {
    ch := make(chan string)
    
    go func() {
        time.Sleep(time.Second * 2)
        ch <- "result"
    }()
    
    select {
    case result := <-ch:
        fmt.Printf("Got result: %s\n", result)
    case <-time.After(time.Second):
        fmt.Println("Timeout!")
    }
}

func cancellationExample() {
    done := make(chan bool)
    
    go func() {
        for {
            select {
            case <-done:
                fmt.Println("Cancelled!")
                return
            default:
                fmt.Println("Working...")
                time.Sleep(time.Millisecond * 100)
            }
        }
    }()
    
    time.Sleep(time.Second)
    close(done) // å‘é€å–æ¶ˆä¿¡å·
    time.Sleep(time.Millisecond * 100)
}
```

## ğŸ¯ select è¯­å¥çš„å¦™ç”¨

### select çš„åŸºæœ¬ç”¨æ³•

```go
func selectBasics() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(time.Second)
        ch1 <- "from ch1"
    }()
    
    go func() {
        time.Sleep(time.Second * 2)
        ch2 <- "from ch2"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Printf("Received: %s\n", msg1)
        case msg2 := <-ch2:
            fmt.Printf("Received: %s\n", msg2)
        case <-time.After(time.Second * 3):
            fmt.Println("Timeout!")
        }
    }
}
```

### select çš„é«˜çº§æŠ€å·§

**1. éé˜»å¡æ“ä½œ**
```go
func nonBlockingSelect() {
    ch := make(chan int)
    
    select {
    case value := <-ch:
        fmt.Printf("Got value: %d\n", value)
    default:
        fmt.Println("No value available")
    }
    
    // éé˜»å¡å‘é€
    select {
    case ch <- 42:
        fmt.Println("Sent value")
    default:
        fmt.Println("Channel is full")
    }
}
```

**2. åŠ¨æ€ select**
```go
func dynamicSelect(channels []<-chan int) <-chan int {
    output := make(chan int)
    
    go func() {
        defer close(output)
        
        // åŠ¨æ€æ„å»º select cases
        cases := make([]reflect.SelectCase, len(channels))
        for i, ch := range channels {
            cases[i] = reflect.SelectCase{
                Dir:  reflect.SelectRecv,
                Chan: reflect.ValueOf(ch),
            }
        }
        
        // ä½¿ç”¨åå°„è¿›è¡ŒåŠ¨æ€ select
        for len(cases) > 0 {
            chosen, value, ok := reflect.Select(cases)
            if !ok {
                // channel å·²å…³é—­ï¼Œç§»é™¤è¿™ä¸ª case
                cases = append(cases[:chosen], cases[chosen+1:]...)
                continue
            }
            output <- value.Interface().(int)
        }
    }()
    
    return output
}
```

## ğŸ›¡ï¸ å¹¶å‘å®‰å…¨çš„æœ€ä½³å®è·µ

### 1. é¿å…ç«æ€æ¡ä»¶

```go
// é”™è¯¯çš„åšæ³•
var counter int

func increment() {
    counter++ // ç«æ€æ¡ä»¶ï¼
}

// æ­£ç¡®çš„åšæ³• 1: ä½¿ç”¨ channel
type SafeCounter struct {
    ch chan int
}

func NewSafeCounter() *SafeCounter {
    sc := &SafeCounter{ch: make(chan int, 1)}
    sc.ch <- 0 // åˆå§‹åŒ–
    return sc
}

func (sc *SafeCounter) Increment() {
    current := <-sc.ch
    sc.ch <- current + 1
}

func (sc *SafeCounter) Get() int {
    return <-sc.ch
}

// æ­£ç¡®çš„åšæ³• 2: ä½¿ç”¨ sync.Mutex
type SafeCounter2 struct {
    mu sync.Mutex
    value int
}

func (sc *SafeCounter2) Increment() {
    sc.mu.Lock()
    defer sc.mu.Unlock()
    sc.value++
}

func (sc *SafeCounter2) Get() int {
    sc.mu.Lock()
    defer sc.mu.Unlock()
    return sc.value
}
```

### 2. é¿å… goroutine æ³„æ¼

```go
// é”™è¯¯çš„åšæ³• - å¯èƒ½æ³„æ¼
func leakyFunction() {
    ch := make(chan int)
    go func() {
        // è¿™ä¸ª goroutine æ°¸è¿œä¸ä¼šç»“æŸ
        for {
            select {
            case <-ch:
                return
            default:
                // åšä¸€äº›å·¥ä½œ
                time.Sleep(time.Millisecond)
            }
        }
    }()
    // å¿˜è®°å…³é—­ channel
}

// æ­£ç¡®çš„åšæ³• - ä½¿ç”¨ context
func properFunction(ctx context.Context) {
    ch := make(chan int)
    
    go func() {
        defer close(ch)
        for {
            select {
            case <-ctx.Done():
                return
            case <-ch:
                return
            default:
                // åšä¸€äº›å·¥ä½œ
                time.Sleep(time.Millisecond)
            }
        }
    }()
    
    // ä½¿ç”¨ context æ§åˆ¶ç”Ÿå‘½å‘¨æœŸ
    go func() {
        time.Sleep(time.Second)
        ctx.Done()
    }()
}
```

### 3. èµ„æºç®¡ç†

```go
// ä½¿ç”¨ sync.WaitGroup ç­‰å¾… goroutine å®Œæˆ
func waitGroupExample() {
    var wg sync.WaitGroup
    
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Printf("Worker %d starting\n", id)
            time.Sleep(time.Second)
            fmt.Printf("Worker %d done\n", id)
        }(i)
    }
    
    wg.Wait()
    fmt.Println("All workers completed")
}

// ä½¿ç”¨ sync.Once ç¡®ä¿åªæ‰§è¡Œä¸€æ¬¡
var once sync.Once

func initialize() {
    once.Do(func() {
        fmt.Println("Initializing...")
        // åˆå§‹åŒ–ä»£ç 
    })
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 1. ä½¿ç”¨å¯¹è±¡æ± 

```go
import "sync"

type ObjectPool struct {
    pool sync.Pool
}

func NewObjectPool() *ObjectPool {
    return &ObjectPool{
        pool: sync.Pool{
            New: func() interface{} {
                return &ExpensiveObject{}
            },
        },
    }
}

func (op *ObjectPool) Get() *ExpensiveObject {
    return op.pool.Get().(*ExpensiveObject)
}

func (op *ObjectPool) Put(obj *ExpensiveObject) {
    // é‡ç½®å¯¹è±¡çŠ¶æ€
    obj.Reset()
    op.pool.Put(obj)
}

type ExpensiveObject struct {
    data []byte
}

func (eo *ExpensiveObject) Reset() {
    eo.data = eo.data[:0]
}
```

### 2. æ‰¹é‡å¤„ç†

```go
func batchProcessor(items []int, batchSize int) {
    batches := make(chan []int)
    
    // åˆ†æ‰¹å‘é€
    go func() {
        defer close(batches)
        for i := 0; i < len(items); i += batchSize {
            end := i + batchSize
            if end > len(items) {
                end = len(items)
            }
            batches <- items[i:end]
        }
    }()
    
    // å¹¶å‘å¤„ç†æ‰¹æ¬¡
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for batch := range batches {
                processBatch(batch)
            }
        }()
    }
    
    wg.Wait()
}

func processBatch(batch []int) {
    // å¤„ç†ä¸€æ‰¹æ•°æ®
    for _, item := range batch {
        // å¤„ç†å•ä¸ªé¡¹ç›®
        _ = item * 2
    }
}
```

## ğŸ§ª è°ƒè¯•å’Œç›‘æ§

### 1. ä½¿ç”¨ pprof åˆ†æ

```go
import (
    "net/http"
    _ "net/http/pprof"
    "runtime/pprof"
)

func startProfiling() {
    // å¯åŠ¨ pprof æœåŠ¡å™¨
    go func() {
        http.ListenAndServe("localhost:6060", nil)
    }()
    
    // æ‰‹åŠ¨ç”Ÿæˆ profile
    f, _ := os.Create("cpu.prof")
    defer f.Close()
    pprof.StartCPUProfile(f)
    defer pprof.StopCPUProfile()
    
    // ä½ çš„ç¨‹åºé€»è¾‘
    runYourProgram()
}

func runYourProgram() {
    // æ¨¡æ‹Ÿç¨‹åºè¿è¡Œ
    for i := 0; i < 1000; i++ {
        go func() {
            time.Sleep(time.Second)
        }()
    }
    time.Sleep(time.Second * 2)
}
```

### 2. ç›‘æ§ goroutine æ•°é‡

```go
func monitorGoroutines() {
    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        fmt.Printf("Active goroutines: %d\n", runtime.NumGoroutine())
    }
}

// åœ¨ç¨‹åºå¯åŠ¨æ—¶å¼€å§‹ç›‘æ§
go monitorGoroutines()
```

## ğŸ¯ å®æˆ˜æ¡ˆä¾‹ï¼šå¹¶å‘çˆ¬è™«

```go
type Crawler struct {
    visited map[string]bool
    mu      sync.RWMutex
    queue   chan string
    results chan string
    workers int
}

func NewCrawler(workers int) *Crawler {
    return &Crawler{
        visited: make(map[string]bool),
        queue:   make(chan string, 1000),
        results: make(chan string, 1000),
        workers: workers,
    }
}

func (c *Crawler) Start(urls []string) {
    // å¯åŠ¨å·¥ä½œåç¨‹
    for i := 0; i < c.workers; i++ {
        go c.worker()
    }
    
    // å‘é€åˆå§‹ URL
    go func() {
        for _, url := range urls {
            c.queue <- url
        }
        close(c.queue)
    }()
    
    // æ”¶é›†ç»“æœ
    go func() {
        for result := range c.results {
            fmt.Printf("Crawled: %s\n", result)
        }
    }()
}

func (c *Crawler) worker() {
    for url := range c.queue {
        if c.isVisited(url) {
            continue
        }
        
        c.markVisited(url)
        
        // æ¨¡æ‹Ÿçˆ¬å–
        time.Sleep(time.Millisecond * 100)
        c.results <- url
        
        // å‘ç°æ–°é“¾æ¥ï¼ˆç®€åŒ–ç‰ˆï¼‰
        newURLs := c.extractLinks(url)
        for _, newURL := range newURLs {
            c.queue <- newURL
        }
    }
}

func (c *Crawler) isVisited(url string) bool {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.visited[url]
}

func (c *Crawler) markVisited(url string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.visited[url] = true
}

func (c *Crawler) extractLinks(url string) []string {
    // æ¨¡æ‹Ÿæå–é“¾æ¥
    return []string{url + "/link1", url + "/link2"}
}
```

## ğŸ¤” æ€»ç»“ä¸€ä¸‹

Go çš„å¹¶å‘ç¼–ç¨‹ç¡®å®å¾ˆä¼˜é›…ï¼Œä½†çœŸæ­£ç”¨å¥½éœ€è¦æ·±å…¥ç†è§£å…¶å·¥ä½œåŸç†ã€‚

**å…³é”®è¦ç‚¹**ï¼š
1. **goroutine å¾ˆè½»é‡**ï¼šå¯ä»¥è½»æ¾åˆ›å»ºå¤§é‡å¹¶å‘ä»»åŠ¡
2. **channel æ˜¯é€šä¿¡çš„æ ¸å¿ƒ**ï¼šé¿å…å…±äº«å†…å­˜ï¼Œé€šè¿‡é€šä¿¡å…±äº«å†…å­˜
3. **select å¾ˆçµæ´»**ï¼šå¤„ç†å¤šä¸ª channel çš„å¹¶å‘æ“ä½œ
4. **context ç®¡ç†ç”Ÿå‘½å‘¨æœŸ**ï¼šä¼˜é›…åœ°å¤„ç†å–æ¶ˆå’Œè¶…æ—¶
5. **æ³¨æ„èµ„æºç®¡ç†**ï¼šé¿å… goroutine æ³„æ¼å’Œç«æ€æ¡ä»¶

**æœ€ä½³å®è·µ**ï¼š
- ğŸš€ ä¼˜å…ˆä½¿ç”¨ channel è€Œä¸æ˜¯å…±äº«å†…å­˜
- ğŸ›¡ï¸ ä½¿ç”¨ context ç®¡ç† goroutine ç”Ÿå‘½å‘¨æœŸ
- ğŸ“Š ç›‘æ§ goroutine æ•°é‡å’Œæ€§èƒ½
- ğŸ”§ åˆç†ä½¿ç”¨ç¼“å†² channel å’Œ select
- ğŸ§ª å……åˆ†æµ‹è¯•å¹¶å‘ä»£ç 

**è¿›é˜¶æ–¹å‘**ï¼š
- **å†…å­˜æ¨¡å‹**ï¼šç†è§£ Go çš„å†…å­˜ä¸€è‡´æ€§ä¿è¯
- **è°ƒåº¦å™¨è°ƒä¼˜**ï¼šGOMAXPROCS å’Œè°ƒåº¦ç­–ç•¥
- **æ€§èƒ½åˆ†æ**ï¼šä½¿ç”¨ pprof å’Œ trace å·¥å…·
- **åˆ†å¸ƒå¼ç³»ç»Ÿ**ï¼šç»“åˆ etcdã€consul ç­‰

å¸Œæœ›è¿™ç¯‡æ·±åº¦è§£æå¯¹ç†è§£ Go å¹¶å‘ç¼–ç¨‹æœ‰å¸®åŠ©ï¼

> ğŸ’¡ **å°è´´å£«**ï¼šå¹¶å‘ç¼–ç¨‹çš„æ ¸å¿ƒæ˜¯ç†è§£æ•°æ®æµï¼Œè€Œä¸æ˜¯æ§åˆ¶æµã€‚Go çš„ channel è®©æ•°æ®æµå˜å¾—æ¸…æ™°å¯è§ã€‚ 