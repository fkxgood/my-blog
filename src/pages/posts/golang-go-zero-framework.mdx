---
layout: ../../layouts/PostLayout.astro
title: go-zero æ¡†æ¶å…¥é—¨æŒ‡å— â€”â€” è®©å¾®æœåŠ¡å¼€å‘å˜å¾—ç®€å•
date: 2024-12-28
category: åç«¯å¼€å‘
description: æ·±å…¥æµ…å‡ºåœ°ä»‹ç» go-zero æ¡†æ¶ï¼Œä»åŸºç¡€æ¦‚å¿µåˆ°å®æˆ˜åº”ç”¨ï¼Œå­¦ä¼šç”¨ go-zero å¿«é€Ÿæ­å»ºå¾®æœåŠ¡ç³»ç»Ÿ
tags:
  - Go
  - Golang
  - go-zero
  - å¾®æœåŠ¡
  - åç«¯æ¡†æ¶
  - åç«¯å¼€å‘
author: fkxgood
---

# go-zero æ¡†æ¶å…¥é—¨æŒ‡å— â€”â€” è®©å¾®æœåŠ¡å¼€å‘å˜å¾—ç®€å•

> go-zero æ˜¯å­—èŠ‚è·³åŠ¨å¼€æºçš„ä¸€ä¸ª Go å¾®æœåŠ¡æ¡†æ¶ï¼Œå·ç§°"è®©å¾®æœåŠ¡å¼€å‘å˜å¾—ç®€å•"ã€‚æœ€è¿‘è¯•äº†è¯•ï¼Œç¡®å®æŒºé¦™çš„ï¼Œæƒ³ç€æŠŠä½¿ç”¨å¿ƒå¾—è®°å½•ä¸‹æ¥ã€‚

## ğŸ¤” ä»€ä¹ˆæ˜¯ go-zeroï¼Ÿä¸ºä»€ä¹ˆé€‰å®ƒï¼Ÿ

### ç®€å•ç†è§£ go-zero

go-zero å°±åƒæ˜¯ä¸€ä¸ª"å¾®æœåŠ¡å¼€å‘å·¥å…·ç®±"ï¼Œå®ƒå¸®ä½ æŠŠæ­å»ºå¾®æœåŠ¡æ—¶é‚£äº›é‡å¤çš„ã€éº»çƒ¦çš„äº‹æƒ…éƒ½æå®šäº†ï¼š

| åŠŸèƒ½ | ä¼ ç»Ÿæ–¹å¼ | go-zero æ–¹å¼ | æ„Ÿå— |
|------|----------|--------------|------|
| **API æœåŠ¡** | æ‰‹å†™è·¯ç”±ã€ä¸­é—´ä»¶ã€é”™è¯¯å¤„ç† | ä¸€è¡Œå‘½ä»¤ç”Ÿæˆå®Œæ•´é¡¹ç›® | çœŸçš„çœå¿ƒ |
| **æ•°æ®åº“æ“ä½œ** | æ‰‹å†™ SQLã€è¿æ¥æ± ã€äº‹åŠ¡ | è‡ªåŠ¨ç”Ÿæˆ CRUD ä»£ç  | ä¸ç”¨å†™é‡å¤ä»£ç  |
| **æœåŠ¡å‘ç°** | è‡ªå·±å®ç°æ³¨å†Œã€å‘ç°é€»è¾‘ | å†…ç½® etcd æ”¯æŒ | å¼€ç®±å³ç”¨ |
| **é…ç½®ç®¡ç†** | æ‰‹å†™é…ç½®è§£æã€çƒ­æ›´æ–° | ç»Ÿä¸€çš„é…ç½®ä¸­å¿ƒ | ç®¡ç†èµ·æ¥æ–¹ä¾¿ |
| **é“¾è·¯è¿½è¸ª** | é›†æˆ Jaegerã€Zipkin | å†…ç½® trace æ”¯æŒ | è°ƒè¯•é—®é¢˜å®¹æ˜“ |

### ä¸ºä»€ä¹ˆé€‰ go-zeroï¼Ÿ

**ğŸš€ å¼€å‘æ•ˆç‡é«˜**
```bash
# ä¸€è¡Œå‘½ä»¤ç”Ÿæˆå®Œæ•´çš„ API æœåŠ¡
goctl api new user-api
```

**ğŸ”§ å·¥å…·é“¾å®Œæ•´**
- `goctl`ï¼šä»£ç ç”Ÿæˆå·¥å…·
- `zrpc`ï¼šRPC æœåŠ¡æ¡†æ¶
- `zapi`ï¼šAPI ç½‘å…³
- `zmon`ï¼šç›‘æ§ç³»ç»Ÿ

**ğŸ“¦ ç”Ÿæ€ä¸°å¯Œ**
- å†…ç½®ç¼“å­˜ã€é™æµã€ç†”æ–­
- æ”¯æŒå¤šç§æ•°æ®åº“
- é›†æˆé“¾è·¯è¿½è¸ª
- å†…ç½®ç›‘æ§æŒ‡æ ‡

## ğŸ¯ go-zero çš„æ ¸å¿ƒç»„ä»¶

### 1. API æœåŠ¡ï¼ˆHTTP æœåŠ¡ï¼‰

**ä¼ ç»Ÿæ–¹å¼å†™ API**
```go
// ä¼ ç»Ÿæ–¹å¼ - è¦å†™å¾ˆå¤šæ ·æ¿ä»£ç 
func main() {
    r := gin.Default()
    
    // ä¸­é—´ä»¶
    r.Use(cors.Default())
    r.Use(logger())
    r.Use(recovery())
    
    // è·¯ç”±
    r.GET("/api/users/:id", getUserHandler)
    r.POST("/api/users", createUserHandler)
    r.PUT("/api/users/:id", updateUserHandler)
    r.DELETE("/api/users/:id", deleteUserHandler)
    
    // é”™è¯¯å¤„ç†
    r.NoRoute(func(c *gin.Context) {
        c.JSON(404, gin.H{"error": "not found"})
    })
    
    r.Run(":8080")
}
```

**go-zero æ–¹å¼**
```go
// go-zero æ–¹å¼ - é…ç½®é©±åŠ¨
// api/user.api
type (
    GetUserReq {
        Id int64 `path:"id"`
    }
    
    GetUserResp {
        Id   int64  `json:"id"`
        Name string `json:"name"`
        Age  int    `json:"age"`
    }
)

service user-api {
    @handler GetUser
    get /api/users/:id (GetUserReq) returns (GetUserResp)
}
```

```bash
# ç”Ÿæˆä»£ç 
goctl api go -api api/user.api -dir .
```

### 2. RPC æœåŠ¡ï¼ˆå†…éƒ¨æœåŠ¡é€šä¿¡ï¼‰

**ä¼ ç»Ÿ gRPC æ–¹å¼**
```protobuf
// è¦å†™ protobuf æ–‡ä»¶
syntax = "proto3";

service UserService {
    rpc GetUser(GetUserRequest) returns (GetUserResponse);
}

message GetUserRequest {
    int64 id = 1;
}

message GetUserResponse {
    int64 id = 1;
    string name = 2;
    int32 age = 3;
}
```

**go-zero æ–¹å¼**
```go
// ç›´æ¥ç”¨ Go è¯­æ³•å®šä¹‰
type (
    GetUserReq {
        Id int64 `json:"id"`
    }
    
    GetUserResp {
        Id   int64  `json:"id"`
        Name string `json:"name"`
        Age  int    `json:"age"`
    }
)

service user-rpc {
    @handler GetUser
    rpc GetUser(GetUserReq) returns (GetUserResp)
}
```

## ğŸš€ å¿«é€Ÿå¼€å§‹ï¼šæ­å»ºä¸€ä¸ªç”¨æˆ·æœåŠ¡

### 1. å®‰è£… go-zero

```bash
# å®‰è£… goctl å·¥å…·
go install github.com/zeromicro/go-zero/tools/goctl@latest

# éªŒè¯å®‰è£…
goctl --version
```

### 2. åˆ›å»º API æœåŠ¡

```bash
# åˆ›å»ºé¡¹ç›®
mkdir user-service && cd user-service

# ç”Ÿæˆ API æœåŠ¡
goctl api new user-api
```

**ç”Ÿæˆçš„ç›®å½•ç»“æ„**
```
user-api/
â”œâ”€â”€ api/
â”‚   â””â”€â”€ user.api          # API å®šä¹‰æ–‡ä»¶
â”œâ”€â”€ etc/
â”‚   â””â”€â”€ user-api.yaml     # é…ç½®æ–‡ä»¶
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ handler/          # å¤„ç†å™¨
â”‚   â”œâ”€â”€ logic/           # ä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ svc/             # æœåŠ¡ä¸Šä¸‹æ–‡
â”‚   â””â”€â”€ types/           # ç±»å‹å®šä¹‰
â”œâ”€â”€ user-api.go          # ä¸»ç¨‹åº
â””â”€â”€ go.mod
```

### 3. å®šä¹‰ API æ¥å£

```go
// api/user.api
type (
    CreateUserReq {
        Name string `json:"name"`
        Age  int    `json:"age"`
    }
    
    CreateUserResp {
        Id int64 `json:"id"`
    }
    
    GetUserReq {
        Id int64 `path:"id"`
    }
    
    GetUserResp {
        Id   int64  `json:"id"`
        Name string `json:"name"`
        Age  int    `json:"age"`
    }
)

service user-api {
    @handler CreateUser
    post /api/users (CreateUserReq) returns (CreateUserResp)
    
    @handler GetUser
    get /api/users/:id (GetUserReq) returns (GetUserResp)
}
```

### 4. ç”Ÿæˆä»£ç 

```bash
# ç”Ÿæˆ Go ä»£ç 
goctl api go -api api/user.api -dir .
```

### 5. å®ç°ä¸šåŠ¡é€»è¾‘

```go
// internal/logic/createuserlogic.go
func (l *CreateUserLogic) CreateUser(req *types.CreateUserReq) (resp *types.CreateUserResp, err error) {
    // è¿™é‡Œå†™ä½ çš„ä¸šåŠ¡é€»è¾‘
    user := &model.User{
        Name: req.Name,
        Age:  req.Age,
    }
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    id, err := l.svcCtx.UserModel.Insert(l.ctx, user)
    if err != nil {
        return nil, err
    }
    
    return &types.CreateUserResp{
        Id: id,
    }, nil
}
```

### 6. é…ç½®æ•°æ®åº“

```yaml
# etc/user-api.yaml
Name: user-api
Host: 0.0.0.0
Port: 8888

MySQL:
  DataSource: root:password@tcp(localhost:3306)/user_db?charset=utf8mb4&parseTime=True&loc=Local

CacheRedis:
  - Host: localhost:6379
    Type: node
```

### 7. è¿è¡ŒæœåŠ¡

```bash
# å¯åŠ¨æœåŠ¡
go run user-api.go -f etc/user-api.yaml
```

## ğŸ”§ go-zero çš„é«˜çº§ç‰¹æ€§

### 1. ä¸­é—´ä»¶ç³»ç»Ÿ

```go
// è‡ªå®šä¹‰ä¸­é—´ä»¶
func AuthMiddleware() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if token == "" {
            http.Error(w, "unauthorized", http.StatusUnauthorized)
            return
        }
        // éªŒè¯ token
        r = r.WithContext(context.WithValue(r.Context(), "user_id", "123"))
        // ç»§ç»­å¤„ç†
    }
}

// åœ¨ API æ–‡ä»¶ä¸­ä½¿ç”¨
service user-api {
    @middleware AuthMiddleware
    @handler GetUser
    get /api/users/:id (GetUserReq) returns (GetUserResp)
}
```

### 2. æ•°æ®åº“æ“ä½œ

**ä¼ ç»Ÿæ–¹å¼**
```go
// æ‰‹å†™ SQL
func GetUser(id int64) (*User, error) {
    query := "SELECT id, name, age FROM users WHERE id = ?"
    row := db.QueryRow(query, id)
    
    var user User
    err := row.Scan(&user.ID, &user.Name, &user.Age)
    if err != nil {
        return nil, err
    }
    return &user, nil
}
```

**go-zero æ–¹å¼**
```bash
# ç”Ÿæˆæ•°æ®åº“æ¨¡å‹
goctl model mysql ddl -src user.sql -dir . -c

# è‡ªåŠ¨ç”Ÿæˆ CRUD æ–¹æ³•
```

```go
// ç”Ÿæˆçš„ä»£ç 
func (m *UserModel) FindOne(ctx context.Context, id int64) (*User, error) {
    // è‡ªåŠ¨ç”Ÿæˆçš„æŸ¥è¯¢é€»è¾‘
}

func (m *UserModel) Insert(ctx context.Context, data *User) (int64, error) {
    // è‡ªåŠ¨ç”Ÿæˆçš„æ’å…¥é€»è¾‘
}
```

### 3. ç¼“å­˜é›†æˆ

```go
// åœ¨ logic ä¸­ä½¿ç”¨ç¼“å­˜
func (l *GetUserLogic) GetUser(req *types.GetUserReq) (resp *types.GetUserResp, err error) {
    // å…ˆä»ç¼“å­˜è·å–
    cacheKey := fmt.Sprintf("user:%d", req.Id)
    var user types.GetUserResp
    err = l.svcCtx.Cache.Get(l.ctx, cacheKey, &user)
    if err == nil {
        return &user, nil
    }
    
    // ç¼“å­˜æ²¡æœ‰ï¼Œä»æ•°æ®åº“è·å–
    dbUser, err := l.svcCtx.UserModel.FindOne(l.ctx, req.Id)
    if err != nil {
        return nil, err
    }
    
    resp = &types.GetUserResp{
        Id:   dbUser.Id,
        Name: dbUser.Name,
        Age:  dbUser.Age,
    }
    
    // è®¾ç½®ç¼“å­˜
    l.svcCtx.Cache.Set(l.ctx, cacheKey, resp)
    
    return resp, nil
}
```

### 4. é™æµå’Œç†”æ–­

```go
// åœ¨ API æ–‡ä»¶ä¸­é…ç½®é™æµ
service user-api {
    @handler GetUser
    get /api/users/:id (GetUserReq) returns (GetUserResp)
}

// åœ¨é…ç½®æ–‡ä»¶ä¸­è®¾ç½®é™æµ
Name: user-api
Host: 0.0.0.0
Port: 8888

Limit:
  Rate: 1000  # æ¯ç§’è¯·æ±‚æ•°
  Burst: 100  # çªå‘è¯·æ±‚æ•°

Breaker:
  Threshold: 5   # é”™è¯¯é˜ˆå€¼
  Timeout: 10s   # ç†”æ–­æ—¶é—´
```

### 5. é“¾è·¯è¿½è¸ª

```go
// è‡ªåŠ¨é›†æˆ trace
func (l *GetUserLogic) GetUser(req *types.GetUserReq) (resp *types.GetUserResp, err error) {
    // è‡ªåŠ¨ç”Ÿæˆ trace span
    span := trace.SpanFromContext(l.ctx)
    defer span.Finish()
    
    // ä½ çš„ä¸šåŠ¡é€»è¾‘
    return resp, nil
}
```

## ğŸ—ï¸ å¾®æœåŠ¡æ¶æ„å®æˆ˜

### 1. æœåŠ¡æ‹†åˆ†

```
user-service/
â”œâ”€â”€ user-api/          # API ç½‘å…³
â”œâ”€â”€ user-rpc/          # ç”¨æˆ·æœåŠ¡
â”œâ”€â”€ order-api/         # è®¢å• API
â”œâ”€â”€ order-rpc/         # è®¢å•æœåŠ¡
â””â”€â”€ payment-rpc/       # æ”¯ä»˜æœåŠ¡
```

### 2. æœåŠ¡é—´é€šä¿¡

```go
// åœ¨ user-api ä¸­è°ƒç”¨ user-rpc
type UserApiLogic struct {
    logx.Logger
    ctx    context.Context
    svcCtx *svc.ServiceContext
}

func (l *UserApiLogic) GetUser(req *types.GetUserReq) (resp *types.GetUserResp, err error) {
    // è°ƒç”¨ RPC æœåŠ¡
    rpcResp, err := l.svcCtx.UserRpc.GetUser(l.ctx, &userpb.GetUserReq{
        Id: req.Id,
    })
    if err != nil {
        return nil, err
    }
    
    return &types.GetUserResp{
        Id:   rpcResp.Id,
        Name: rpcResp.Name,
        Age:  rpcResp.Age,
    }, nil
}
```

### 3. é…ç½®ä¸­å¿ƒ

```yaml
# etcd é…ç½®
Etcd:
  Hosts:
    - 127.0.0.1:2379
  Key: user.rpc

# æœåŠ¡å‘ç°
Target: etcd://127.0.0.1:2379/user.rpc
```

## ğŸ¯ å®é™…é¡¹ç›®ç»éªŒ

### 1. é¡¹ç›®ç»“æ„æœ€ä½³å®è·µ

```
myproject/
â”œâ”€â”€ api/              # API å®šä¹‰
â”œâ”€â”€ rpc/              # RPC æœåŠ¡
â”œâ”€â”€ shared/           # å…±äº«ä»£ç 
â”‚   â”œâ”€â”€ constants/    # å¸¸é‡
â”‚   â”œâ”€â”€ errors/       # é”™è¯¯å®šä¹‰
â”‚   â””â”€â”€ utils/        # å·¥å…·å‡½æ•°
â”œâ”€â”€ deploy/           # éƒ¨ç½²é…ç½®
â”‚   â”œâ”€â”€ docker/       # Docker é…ç½®
â”‚   â””â”€â”€ k8s/          # Kubernetes é…ç½®
â””â”€â”€ scripts/          # è„šæœ¬æ–‡ä»¶
```

### 2. é”™è¯¯å¤„ç†

```go
// å®šä¹‰é”™è¯¯ç 
const (
    ErrUserNotFound = "user not found"
    ErrInvalidParam = "invalid parameter"
)

// åœ¨ logic ä¸­ä½¿ç”¨
func (l *GetUserLogic) GetUser(req *types.GetUserReq) (resp *types.GetUserResp, err error) {
    if req.Id <= 0 {
        return nil, errors.New(ErrInvalidParam)
    }
    
    user, err := l.svcCtx.UserModel.FindOne(l.ctx, req.Id)
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, errors.New(ErrUserNotFound)
        }
        return nil, err
    }
    
    return &types.GetUserResp{
        Id:   user.Id,
        Name: user.Name,
        Age:  user.Age,
    }, nil
}
```

### 3. æ—¥å¿—å’Œç›‘æ§

```go
// ç»“æ„åŒ–æ—¥å¿—
func (l *CreateUserLogic) CreateUser(req *types.CreateUserReq) (resp *types.CreateUserResp, err error) {
    logx.WithContext(l.ctx).Infof("creating user: name=%s, age=%d", req.Name, req.Age)
    
    // ä¸šåŠ¡é€»è¾‘
    
    logx.WithContext(l.ctx).Infof("user created: id=%d", resp.Id)
    return resp, nil
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 1. æ•°æ®åº“ä¼˜åŒ–

```go
// ä½¿ç”¨è¿æ¥æ± 
MySQL:
  DataSource: root:password@tcp(localhost:3306)/user_db?charset=utf8mb4&parseTime=True&loc=Local
  MaxOpenConns: 100
  MaxIdleConns: 10
  ConnMaxLifetime: 3600s
```

### 2. ç¼“å­˜ç­–ç•¥

```go
// å¤šçº§ç¼“å­˜
func (l *GetUserLogic) GetUser(req *types.GetUserReq) (resp *types.GetUserResp, err error) {
    // L1: æœ¬åœ°ç¼“å­˜
    if user, ok := l.localCache.Get(req.Id); ok {
        return user.(*types.GetUserResp), nil
    }
    
    // L2: Redis ç¼“å­˜
    cacheKey := fmt.Sprintf("user:%d", req.Id)
    var user types.GetUserResp
    if err := l.svcCtx.Cache.Get(l.ctx, cacheKey, &user); err == nil {
        l.localCache.Set(req.Id, &user, time.Minute*5)
        return &user, nil
    }
    
    // L3: æ•°æ®åº“
    dbUser, err := l.svcCtx.UserModel.FindOne(l.ctx, req.Id)
    if err != nil {
        return nil, err
    }
    
    resp = &types.GetUserResp{
        Id:   dbUser.Id,
        Name: dbUser.Name,
        Age:  dbUser.Age,
    }
    
    // å›å¡«ç¼“å­˜
    l.svcCtx.Cache.Set(l.ctx, cacheKey, resp, time.Hour)
    l.localCache.Set(req.Id, resp, time.Minute*5)
    
    return resp, nil
}
```

### 3. å¹¶å‘å¤„ç†

```go
// ä½¿ç”¨ goroutine å¤„ç†å¹¶å‘ä»»åŠ¡
func (l *GetUserLogic) GetUserWithOrders(req *types.GetUserReq) (resp *types.GetUserWithOrdersResp, err error) {
    var wg sync.WaitGroup
    var user *types.GetUserResp
    var orders []*types.Order
    
    // å¹¶å‘è·å–ç”¨æˆ·ä¿¡æ¯å’Œè®¢å•
    wg.Add(2)
    
    go func() {
        defer wg.Done()
        user, _ = l.GetUser(req)
    }()
    
    go func() {
        defer wg.Done()
        orders, _ = l.GetUserOrders(req.Id)
    }()
    
    wg.Wait()
    
    return &types.GetUserWithOrdersResp{
        User:   user,
        Orders: orders,
    }, nil
}
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### 1. å•å…ƒæµ‹è¯•

```go
func TestGetUserLogic_GetUser(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    
    mockUserModel := mock.NewMockUserModel(ctrl)
    mockUserModel.EXPECT().
        FindOne(gomock.Any(), int64(1)).
        Return(&model.User{Id: 1, Name: "Alice", Age: 25}, nil)
    
    l := NewGetUserLogic(context.Background(), &svc.ServiceContext{
        UserModel: mockUserModel,
    })
    
    resp, err := l.GetUser(&types.GetUserReq{Id: 1})
    
    assert.NoError(t, err)
    assert.Equal(t, "Alice", resp.Name)
    assert.Equal(t, 25, resp.Age)
}
```

### 2. é›†æˆæµ‹è¯•

```go
func TestUserAPI_GetUser(t *testing.T) {
    server := httptest.NewServer(handler)
    defer server.Close()
    
    resp, err := http.Get(server.URL + "/api/users/1")
    assert.NoError(t, err)
    assert.Equal(t, http.StatusOK, resp.StatusCode)
    
    var result types.GetUserResp
    json.NewDecoder(resp.Body).Decode(&result)
    assert.Equal(t, "Alice", result.Name)
}
```

## ğŸ¤” æ€»ç»“ä¸€ä¸‹

go-zero ç¡®å®è®©å¾®æœåŠ¡å¼€å‘å˜å¾—ç®€å•äº†å¾ˆå¤šï¼Œç‰¹åˆ«æ˜¯å¯¹äºä¸­å°å‹é¡¹ç›®ã€‚

**go-zero çš„ä¼˜åŠ¿**ï¼š
- ğŸš€ å¼€å‘æ•ˆç‡é«˜ï¼Œä»£ç ç”Ÿæˆå¾ˆå¼ºå¤§
- ğŸ”§ å·¥å…·é“¾å®Œæ•´ï¼Œä»å¼€å‘åˆ°éƒ¨ç½²éƒ½æœ‰æ”¯æŒ
- ğŸ“¦ å†…ç½®åŠŸèƒ½ä¸°å¯Œï¼Œç¼“å­˜ã€é™æµã€ç†”æ–­éƒ½æœ‰
- ğŸ›¡ï¸ ç”Ÿäº§å°±ç»ªï¼Œå­—èŠ‚è·³åŠ¨å†…éƒ¨å¤§é‡ä½¿ç”¨
- ğŸ“– æ–‡æ¡£é½å…¨ï¼Œç¤¾åŒºæ´»è·ƒ

**ä¸å¤ªçˆ½çš„åœ°æ–¹**ï¼š
- ğŸ“ å­¦ä¹ æ›²çº¿ç›¸å¯¹é™¡å³­ï¼Œæ¦‚å¿µæ¯”è¾ƒå¤š
- ğŸ” è°ƒè¯•ç›¸å¯¹å¤æ‚ï¼Œç‰¹åˆ«æ˜¯ RPC è°ƒç”¨
- ğŸ“Š ç›‘æ§å’Œæ—¥å¿—éœ€è¦é¢å¤–é…ç½®
- ğŸ› é”™è¯¯å¤„ç†æœ‰æ—¶å€™ä¸å¤Ÿç›´è§‚

**ä½¿ç”¨å»ºè®®**ï¼š
1. **å…ˆä»å°é¡¹ç›®å¼€å§‹**ï¼šç†Ÿæ‚‰åŸºæœ¬æ¦‚å¿µå’Œå·¥å…·
2. **å¤šçœ‹å®˜æ–¹ç¤ºä¾‹**ï¼šç†è§£æœ€ä½³å®è·µ
3. **åˆç†ä½¿ç”¨ä»£ç ç”Ÿæˆ**ï¼šä¸è¦è¿‡åº¦ä¾èµ–
4. **æ³¨æ„æ€§èƒ½è°ƒä¼˜**ï¼šç¼“å­˜ã€è¿æ¥æ± ç­‰é…ç½®
5. **åšå¥½ç›‘æ§å’Œæ—¥å¿—**ï¼šç”Ÿäº§ç¯å¢ƒå¾ˆé‡è¦

**é€‚ç”¨åœºæ™¯**ï¼š
- ğŸ¢ ä¸­å°å‹å¾®æœåŠ¡é¡¹ç›®
- ğŸš€ éœ€è¦å¿«é€Ÿå¼€å‘çš„é¡¹ç›®
- ğŸ“± é«˜å¹¶å‘åœºæ™¯
- ğŸ”§ æœ‰ä¸€å®š Go åŸºç¡€